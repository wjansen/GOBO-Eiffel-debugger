note

	description:
		"Abstract class scanning the persistence closure of one object."

deferred class PC_DRIVER [TI_, SI_ -> attached ANY]
	-- TI_: type of idents generated by the `target' 
	-- SI_: type of idents generated by the `source' 

inherit

	PC_BASE

	IS_BASE

	MEMORY

feature {NONE} -- Initialization 

	make (t: like target; s: like source; order, opts: INTEGER;
			oo: like known_objects)
		note
			action: ""
			t: "traversal target"
			s: "traversal source"
			ord: 
				"[
				 traversal ordering:
				 one of `Fifo_flag', `Lifo_flag', `Deep_flag', `Forward_flag'
				 ]"
			opts: "ORing of non-traversal options"
			oo: "auxiliary storage"
		require
			valid_target: target_valid (t)
			valid_source: source_valid (s)
			valid_flags: valid_flags (opts)
			when_target_expands_strings: t.must_expand_strings implies s.can_expand_strings
			when_source_expands_strings: s.must_expand_strings implies t.can_expand_strings
		do
			target := t
			source := s
			once_observing := opts & Once_observation_flag /= 0
			deep := order & Deep_flag > 0 and then order /= Forward_flag
			forward := False
			expand_strings := target.must_expand_strings or source.must_expand_strings
			known_objects := oo
		ensure
			taget_set: target = t
			source_set: source = s
		end

	reset
		note
			action: "Clear table of known objects."
		do
			known_objects.clear
		ensure
			objects_empty: known_objects.is_empty
		end

feature -- Access 
	
	flags: INTEGER

	valid_flags (f: INTEGER): BOOLEAN
		deferred
		end

	source: PC_SOURCE [SI_]
			-- Persistence closure to read from.

	source_void_ident: detachable SI_
			-- Ident of `Void' attributes in `source'. 

	source_root_ident: detachable SI_
			-- Root of traversal in `source'. 

	target: PC_TARGET [TI_]
			-- Persistence closure to write to.

	target_void_ident: detachable TI_
			-- Ident of `Void' attributes in `target'. 

	target_root_ident: detachable TI_
			-- Root of traversal in `target'. 
		local
			tid: PC_TYPED_IDENT [TI_]
		do
			if source_root_ident /= source_void_ident
				and then attached source_root_ident as si
			 then
				tid := known_objects [si]
				Result := tid.ident
			end
		end

	root_type: IS_TYPE
			-- Type of root of traversal.
		local
			tid: PC_TYPED_IDENT [TI_]
		do
			if source_root_ident /= source_void_ident then
				tid := known_objects [source_root_ident]
				Result := tid.type
			end
		end

	known_objects: PC_TABLE [PC_TYPED_IDENT [TI_], SI_]

feature -- Status 

	valid_target (t: like target): BOOLEAN
		deferred
		end
			
	valid_source (s: like source): BOOLEAN
		deferred
		end
			
	is_in_order: BOOLEAN
		do
			Result := deep
		end

	is_pre_order: BOOLEAN
		do
			Result := (flags & Order_flag) = Fifo_flag
		end

	is_post_order: BOOLEAN
		do
			Result := (flags & Order_flag) = Lifo_flag
		end

	is_forwarding: BOOLEAN
		do
			Result := (flags & Order_flag) = Forward_flag
		end

feature -- Basic operation 

	do_all (action: PROCEDURE [ANY, TUPLE [PC_TYPED_IDENT [TI_], SI_]])
		note
			action: "Apply `action' to all pairs of target idents and source idents."
		do
			known_objects.do_pairs (action)
		end
	
feature {NONE} -- Scanning structures 

	traverse
		note
			action:
			"[
			 Deep traversal of an object given the `source'.
			 Set `source_root_ident' accordingly.
			 ]"
		local
			tid: PC_TYPED_IDENT [TI_]
			was_collecting: BOOLEAN
		do
			reset
			full_collect
			was_collecting := collecting
			collection_off
			process_closure
			if was_collecting then
				collection_on
			end
			if attached source.finalize as fin then
				known_objects.do_keys (fin)
			end
			if attached target.finalize as fin then
				known_objects.do_values (fin)
			end
			if source_root_ident /= source_void_ident
			 then
				tid := known_objects [source_root_ident]
				target.finish (tid.ident, tid.type)
			end
		end

	process_closure
		note
			action:
			"[
			 Process the persistence closure of the `source_root_ident'.
			 ]"
		require
			nothing_todo: todo_count = 0
		local
			tid: PC_TYPED_IDENT [TI_]
		do
			move_to_next_ident
			from
				if next_ident /= source_void_ident then
					process_announcement (next_ident)
				end
			until todo_count = 0 loop
				move_to_next_ident
				tid := known_objects[next_ident]
				process_data (next_ident, tid)
			end
			move_to_next_ident
			source_root_ident := next_ident
		ensure
			ready: todo_count = 0
		end

	process_announcement (si: SI_)
		note
			action:
				"[
				 Announce object and put it as key into `known_objects',
				 its value is obtained from `target'.
				 ]"
			si: "source ident"
		require
			is_object: si /= source_void_ident
			unknown: not known_objects.has (si)
		local
			tid: PC_TYPED_IDENT [TI_]
			t: IS_TYPE
			ti: TI_
			n: NATURAL
		do
			source.read_description
			t := source.last_dynamic_type
			n := source.last_count
			tid.make (target.void_ident, t, n)
			if t.is_special and then attached {IS_SPECIAL_TYPE} t as st then
				target.put_new_special (st, n, n)
			else
				target.put_new_object (t)
			end
			ti := target.last_ident
			if once_observing then
				source.read_once (si)
				target.put_once (source.last_class, source.last_string, ti)
				ti := target.last_ident
			end
			tid.make (ti, t, tid.count)
			known_objects [si] := tid
			if deep then
				process_data (si, tid)
			else
				add_todo (si)
			end
		ensure
			known: known_objects.has (si)
		end

	process_data (si: SI_; tid: PC_TYPED_IDENT [TI_])
 		require
			todo: todo_count > 0
			is_object: si /= source_void_ident
			known: known_objects.has (si)
		local
			t: IS_TYPE
			ti: TI_
			n: NATURAL
		do
			remove_todo (si)
			ti := tid.ident
			t := tid.type
			if not deep then
				target.put_next_ident (ti)
			end
			if t.is_special and then attached {IS_SPECIAL_TYPE} t as st then
				n := tid.count
				process_special (st, n, si, ti)
			elseif t.is_agent and then attached {IS_AGENT_TYPE} t as at then
				process_agent (at, si, ti)
			else
				process_normal_or_tuple (t, si, ti)
			end
		ensure	
			known: known_objects.has (si)
						 and then known_objects [si].ident /= target_void_ident
		end

	process_normal_or_tuple (t: IS_TYPE; si: detachable SI_; ti: detachable TI_)
		require
			not_special: not t.is_special
			not_agent: not t.is_agent
			si_not_null: si /= source_void_ident
		local
			f: IS_FIELD
			k, n: INTEGER
			is_string, is_unicode: BOOLEAN
		do
			if not expand_strings then
				is_string := t.is_string
				is_unicode := t.is_unicode
			end
			source.pre_object (t, si)
			target.pre_object (t, ti)
			if is_string then
				source.read_string
				target.put_string (source.last_string)
			elseif is_unicode then
				source.read_unicode
				target.put_unicode (source.last_unicode)
			else
				from
					n := t.field_count
				until k = n loop
					f := t.field_at (k)
					source.set_field (f, si)
					target.set_field (f, ti)
					process_entity (f.type)
					k := k + 1
				end
			end
			source.post_object (t, si)
			target.post_object (t, ti)
		end

	process_agent (a: IS_AGENT_TYPE; si: SI_; ti: TI_)
		require
			si_not_null: si /= source_void_ident
		local
			f: IS_FIELD
			k, n: INTEGER
		do
			n := a.closed_operand_count
			source.pre_object (a, si)
			target.pre_object (a, ti)
			if n > 0 then
				source.pre_agent (a, si)
				target.pre_agent (a, ti)
				from
					k := 0
				until k = n loop
					f := a.field_at (k)
					source.set_field (f, si)
					target.set_field (f, ti)
					process_entity (f.type)
					k := k + 1
				end
				source.post_agent (a, si)
				target.post_agent (a, ti)
			end
			if attached a.last_result as r then
				source.set_field (r, si)
				target.set_field (r, ti)
				process_entity (r.type)
			end
			source.post_object (a, si)
			target.post_object (a, ti)
		end

	process_special (s: IS_SPECIAL_TYPE; n: NATURAL; si: SI_; ti: TI_)
		note
			action: "Process `SPECIAL' of generic type `s'."
			n: "count"
			si: "source ident"
			ti: "target ident"
		require
			si_not_null: si /= source_void_ident
		local
			it: IS_TYPE
			f: IS_FIELD
			k: NATURAL
			i: INTEGER
		do
			it := s.item_type
			source.pre_special (s, n, si)
			target.pre_special (s, n, ti)
			if it.is_basic then
				source.set_index (s, 0, si)
				target.set_index (s, 0, ti)
				i := n.to_integer_32
				inspect it.ident
				when Boolean_ident then
					target.put_booleans (source.booleans, i)
				when Character_ident then
					target.put_characters (source.characters, i)
				when Char32_ident then
					target.put_characters_32 (source.characters_32, i)
				when Int8_ident then
					target.put_integers_8 (source.integers_8, i)
				when Int16_ident then
					target.put_integers_16 (source.integers_16, i)
				when Integer_ident then
					target.put_integers (source.integers, i)
				when Int64_ident then
					target.put_integers_64 (source.integers_64, i)
				when Nat8_ident then
					target.put_naturals_8 (source.naturals_8, i)
				when Nat16_ident then
					target.put_naturals_16 (source.naturals_16, i)
				when Nat32_ident then
					target.put_naturals (source.naturals, i)
				when Nat64_ident then
					target.put_naturals_64 (source.naturals_64, i)
				when Real32_ident then
						target.put_reals (source.reals, i)
				when Real64_ident then
					target.put_doubles (source.doubles, i)
				when Pointer_ident then
					target.put_pointers (source.pointers, i)
				else
				end
			else
				from
					f := s.item_0
				until k = n loop
					source.set_index (s, k, si)
					target.set_index (s, k, ti)
					process_entity (f.type)
					k := k + 1
				end
			end
			source.post_special (s, si)
			target.post_special (s, ti)
		end

	process_entity (static: IS_TYPE)
		note
			action: "Process entity `f'."
			f: "field descriptor"
		local
			tid: PC_TYPED_IDENT [TI_]
			ti: TI_
			si: detachable SI_
		do
			if static.is_basic then
				process_basic_field (static)
			elseif static.is_subobject then
				process_normal_or_tuple (static, source_void_ident, target_void_ident)
			else
				source.read_field_ident
				si := source.last_ident
				if si /= source_void_ident then
					if known_objects.has (si) then
						tid := known_objects [si]
						ti := tid.ident
						if ti /= target_void_ident then
							target.put_known_ident (tid.type, ti)
						else
							target.put_void_ident (static)
						end
					else
						process_announcement (si)
					end
				else
					target.put_void_ident (static)
				end
			end
		end

	process_basic_field (t: IS_TYPE)
		note
			action: "Process entity of basic expanded type `t'."
			t: "type descriptor"
		require
			is_expanded: t.is_basic
		do
			inspect t.ident
			when Boolean_ident then
				source.read_boolean
				target.put_boolean (source.last_boolean)
			when Character_ident then
				source.read_character
				target.put_character (source.last_character)
			when Char32_ident then
				source.read_character_32
				target.put_character_32 (source.last_character_32)
			when Int8_ident then
				source.read_integer_8
				target.put_integer (source.last_integer)
			when Int16_ident then
				source.read_integer_16
				target.put_integer (source.last_integer)
			when Int32_ident then
				source.read_integer
				target.put_integer (source.last_integer)
			when Int64_ident then
				source.read_integer_64
				target.put_integer_64 (source.last_integer_64)
			when Nat8_ident then
				source.read_natural_8
				target.put_natural (source.last_natural)
			when Nat16_ident then
				source.read_natural_16
				target.put_natural (source.last_natural)
			when Nat32_ident then
				source.read_natural
				target.put_natural (source.last_natural)
			when Nat64_ident then
				source.read_natural_64
				target.put_natural_64 (source.last_natural_64)
			when Real32_ident then
				source.read_real
				target.put_real (source.last_real)
			when Real64_ident then
				source.read_double
				target.put_double (source.last_double)
			when Pointer_ident then
				source.read_pointer
				target.put_pointer (source.last_pointer)
			else
			end
		end

feature {NONE} -- Implementation 

	deep, forward: BOOLEAN

	once_observing: BOOLEAN

	expand_strings: BOOLEAN

	todo_count: INTEGER
		deferred
		end
	
	add_todo (si: SI_)
		note
			action: "Add `si' to the set of announced objects."
		deferred
		ensure
			added: todo_count = old todo_count + 1
		end
	
	remove_todo (si: SI_)
		note
			action: "Add `si' to the set of announced objects."
		deferred
		ensure
			removed: todo_count = old todo_count - 1
		end
	
	next_ident: like source_void_ident
	next_tid: PC_TYPED_IDENT [TI_]
	
	move_to_next_ident
		note
			action:
			"[
			 Set `next_typed_ident' to the ident whose data are to be processed next
			 if `todo_count>0', otherwise, to `source_root_ident'.
			 ]"
			 with_description: "Is `next_tid' to be filled?"
		require
			todo: todo_count > 0 
		deferred
		ensure
			not_changed: todo_count = old todo_count
			when_ready: todo_count = 0 implies next_ident = source_root_ident
		end
	
invariant

	deep_definition: deep = ((flags & Order_flag) = Deep_flag)
	forward_definition: forward = ((flags & Order_flag) = Forward_flag)
	todo_count_not_negative: todo_count >= 0

note

	author: "Wolfgang Jansen"
	date: "$Date$"
	revision: "$Revision$"

end
