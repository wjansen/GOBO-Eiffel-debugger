note

	description:
		"Abstract class scanning the persistence closure of one object."

deferred class PC_DRIVER [TI_, SI_ -> attached ANY]
	-- TI_: type of idents generated by the `target' 
	-- SI_: type of idents generated by the `source' 

inherit

	PC_BASE

	IS_BASE

	MEMORY

feature {NONE} -- Initialization 

	common_make (t: like target; s: like source; opts: INTEGER;
			oo: like known_objects)
		local
			ord: INTEGER
		do
			target := t
			source := s
			known_objects := oo
			once_observing := opts & Once_observation_flag /= 0
			ord := opts & Order_flag
			deep := ord & Deep_flag > 0 and then ord /= Forward_flag
			forward := False
			expand_strings := target.must_expand_strings or source.must_expand_strings
		ensure
			taget_set: target = t
			source_set: source = s
		end

	reset
		note
			action: "Clear table of known objects."
		do
			known_objects.clear
		ensure
			objects_empty: known_objects.is_empty
		end

feature -- Access 
	
	flags: INTEGER

	valid_flags (f: INTEGER): BOOLEAN
		deferred
		end

	source: PC_SOURCE [SI_]
			-- Persistence closure to read from.

	source_void_ident: detachable SI_
			-- Ident of `Void' attributes in `source'. 

	source_root_ident: detachable SI_
			-- Root of traversal in `source'. 

	target: PC_TARGET [TI_]
			-- Persistence closure to write to.

	target_void_ident: detachable TI_
			-- Ident of `Void' attributes in `target'. 

	target_root_ident: detachable TI_
			-- Root of traversal in `target'. 
		do
			if source_root_ident /= source_void_ident then
				Result := known_objects [source_root_ident].ident
			end
		end

	root_type: IS_TYPE
			-- Type of root of traversal. 
		do
			if source_root_ident /= source_void_ident then
				Result := known_objects [source_root_ident].type
			end
		end

feature -- Status 

	is_in_order: BOOLEAN
		do
			Result := deep
		end

	is_pre_order: BOOLEAN
		do
			Result := (flags & Order_flag) = Fifo_flag
		end

	is_post_order: BOOLEAN
		do
			Result := (flags & Order_flag) = Lifo_flag
		end

	is_forwarding: BOOLEAN
		do
			Result := (flags & Order_flag) = Forward_flag
		end

feature -- Basic operation 

	do_all (action: PROCEDURE [ANY, TUPLE [PC_TYPED_IDENT [TI_], SI_]])
		note
			action: "Apply `action' to all pairs of target idents and source idents."
		do
			known_objects.do_pairs (action)
		end
	
feature {NONE} -- Scanning structures 

	common_traverse
		note
			action: "Deep traversal of an object given the `source'."
		local
			si: SI_
			was_collecting: BOOLEAN
		do
			reset
			full_collect
			was_collecting := collecting
			collection_off
			process_closure
			if was_collecting then
				collection_on
			end
			if attached source.finalize as fin then
				known_objects.do_keys (fin)
			end
			if attached target.finalize as fin then
				known_objects.do_values (fin)
			end
			si := source_root_ident
			if si /= Void then
				target.finish (known_objects [si])
			end
		end

	process_closure
		note
			action: "Process a whole persistence closure."
		deferred
		end

	process_announcement (si: SI_)
		note
			action:
				"[
				 Announce object and put it as key into `known_objects',
				 its value is obtained from `target'.
				 ]"
			si: "source ident"
		require
			is_object: si /= source_void_ident
			not_known: not known_objects.has (si)
		local
			tid: PC_TYPED_IDENT [TI_]
			ti, ti0: detachable TI_
			dyn: IS_TYPE
			n: NATURAL
		do
			source.adjust_to (si)
			dyn := source.last_dynamic_type
			check dyn /= Void end
			if dyn.is_special and then attached {IS_SPECIAL_TYPE} dyn as st then
				n := source.last_count
				target.put_new_special (st, n, source.last_capacity)
			else
				target.put_new_object (dyn)
			end
			ti := target.last_ident
			if once_observing then
				source.read_once (si)
				target.put_once (source.last_class, source.last_string, ti)
				ti := target.last_ident
			end
			tid.make (ti, dyn, n)
			known_objects [si] := tid
			if deep then
				process_data (si)
			else
				add_announced (si)
			end
		ensure
			known: known_objects.has (si)
		end

	add_announced (si: SI_)
		note
			action: "Add `si' to the set of announced objects"
		deferred
		end
	
	process_data (si: SI_)
		require
			known: known_objects.has (si)
		local
			tid: PC_TYPED_IDENT [TI_]
			ti: TI_
			t: IS_TYPE
		do
			tid := known_objects [si]
			ti := tid.ident
			if not deep then
				target.put_next_ident (ti)
			end
			t := tid.type
			if t.is_special and then attached {IS_SPECIAL_TYPE} t as s then
				process_special (s, tid.count, si, ti, False)
			elseif t.is_agent and then attached {IS_AGENT_TYPE} t as a then
				process_agent (a, si, ti, False)
			else
				process_normal_or_tuple (t, si, ti, False)
			end
		ensure
			known: known_objects.has (si)
		end

	process_normal_or_tuple (t: IS_TYPE; si: detachable SI_; ti: detachable TI_;
													 in_process: BOOLEAN)
		require
			not_special: not t.is_special
			not_agent: not t.is_agent
			si_not_null: si /= source_void_ident
		local
			f: IS_FIELD
			k, n: INTEGER
			is_string, is_unicode: BOOLEAN
		do
			if not expand_strings then
				is_string := t.is_string
				is_unicode := t.is_unicode
			end
			if not in_process then
				source.pre_object (t, si)
				target.pre_object (t, ti)
			end
			if is_string then
				source.read_string
				target.put_string (source.last_string)
			elseif is_unicode then
				source.read_unicode
				target.put_unicode (source.last_unicode)
			else
				from
					n := t.field_count
				until k = n loop
					f := t.field_at (k)
					source.set_field (f, si)
					target.set_field (f, ti)
					process_entity (f)
					k := k + 1
				end
			end
			if not in_process then
				source.post_object (t, si)
				target.post_object (t, ti)
			end
		end

	process_agent (a: IS_AGENT_TYPE; si: SI_; ti: detachable TI_;
													 in_process: BOOLEAN)
		require
			si_not_null: si /= source_void_ident
		local
			f: IS_FIELD
			k, n: INTEGER
		do
			n := a.closed_operand_count
			if not in_process then
				source.pre_object (a, si)
				target.pre_object (a, ti)
			end
			if n > 0 then
				source.pre_agent (a, si)
				target.pre_agent (a, ti)
				from
					k := 0
				until k = n loop
					f := a.field_at (k)
					source.set_field (f, si)
					target.set_field (f, ti)
					process_entity (f)
					k := k + 1
				end
				source.post_agent (a, si)
				target.post_agent (a, ti)
			end
			if attached a.last_result as r then
				source.set_field (r, si)
				target.set_field (r, ti)
				process_entity (r)
			end
			if not in_process then
				source.post_object (a, si)
				target.post_object (a, ti)
			end
		end

	process_special (s: IS_SPECIAL_TYPE; n: NATURAL; si: SI_; ti: detachable TI_;
			in_process: BOOLEAN)
		note
			action: "Process `SPECIAL' of generic type `s'."
			n: "count"
			si: "source ident"
			ti: "target ident"
		require
			si_not_null: si /= source_void_ident
		local
			it: IS_TYPE
			f: IS_FIELD
			k: NATURAL
			i: INTEGER
		do
			it := s.item_type
			if not in_process then
				source.pre_special (s, n, si)
				target.pre_special (s, n, ti)
			end
			if it.is_basic then
				source.set_index (s, 0, si)
				target.set_index (s, 0, ti)
				i := n.to_integer_32
				inspect it.ident
				when Boolean_ident then
					target.put_booleans (source.booleans, i)
				when Character_ident then
					target.put_characters (source.characters, i)
				when Char32_ident then
					target.put_characters_32 (source.characters_32, i)
				when Int8_ident then
					target.put_integers_8 (source.integers_8, i)
				when Int16_ident then
					target.put_integers_16 (source.integers_16, i)
				when Integer_ident then
					target.put_integers (source.integers, i)
				when Int64_ident then
					target.put_integers_64 (source.integers_64, i)
				when Nat8_ident then
					target.put_naturals_8 (source.naturals_8, i)
				when Nat16_ident then
					target.put_naturals_16 (source.naturals_16, i)
				when Nat32_ident then
					target.put_naturals (source.naturals, i)
				when Nat64_ident then
					target.put_naturals_64 (source.naturals_64, i)
				when Real32_ident then
						target.put_reals (source.reals, i)
				when Real64_ident then
					target.put_doubles (source.doubles, i)
				when Pointer_ident then
					target.put_pointers (source.pointers, i)
				else
				end
			else
				from
					f := s.item_0
				until k = n loop
					source.set_index (s, k, si)
					target.set_index (s, k, ti)
					process_entity (f)
					k := k + 1
				end
			end
			if not in_process then
				source.post_special (s, si)
				target.post_special (s, ti)
			end
		end

	process_entity (f: IS_ENTITY)
		note
			action: "Process entity `f'."
			f: "field descriptor"
		local
			tid: PC_TYPED_IDENT [TI_]
			si, si0: detachable SI_
			ti0: detachable TI_
			t: IS_TYPE
		do
			t := f.type
			if t.is_basic then
				process_basic_field (t)
			elseif t.is_subobject then
				process_normal_or_tuple (t, si0, ti0, False)
			else
				source.read_field_ident
				si := source.last_ident
				if si /= source_void_ident then
					if known_objects.has (si) then
						tid := known_objects [si]
						t := source.last_dynamic_type
						target.put_known_ident (tid.ident, tid.type)
					else
						process_announcement (si)
					end
				else
					target.put_void_ident (t)
				end
			end
		end

	process_basic_field (t: IS_TYPE)
		note
			action: "Process entity of basic expanded type `t'."
			t: "type descriptor"
		require
			is_expanded: t.is_basic
		do
			inspect t.ident
			when Boolean_ident then
				source.read_boolean
				target.put_boolean (source.last_boolean)
			when Character_ident then
				source.read_character
				target.put_character (source.last_character)
			when Char32_ident then
				source.read_character_32
				target.put_character_32 (source.last_character_32)
			when Int8_ident then
				source.read_integer_8
				target.put_integer (source.last_integer)
			when Int16_ident then
				source.read_integer_16
				target.put_integer (source.last_integer)
			when Int32_ident then
				source.read_integer
				target.put_integer (source.last_integer)
			when Int64_ident then
				source.read_integer_64
				target.put_integer_64 (source.last_integer_64)
			when Nat8_ident then
				source.read_natural_8
				target.put_natural (source.last_natural)
			when Nat16_ident then
				source.read_natural_16
				target.put_natural (source.last_natural)
			when Nat32_ident then
				source.read_natural
				target.put_natural (source.last_natural)
			when Nat64_ident then
				source.read_natural_64
				target.put_natural_64 (source.last_natural_64)
			when Real32_ident then
				source.read_real
				target.put_real (source.last_real)
			when Real64_ident then
				source.read_double
				target.put_double (source.last_double)
			when Pointer_ident then
				source.read_pointer
				target.put_pointer (source.last_pointer)
			else
			end
		end

feature {NONE} -- Implementation 

	deep, forward: BOOLEAN

	once_observing: BOOLEAN

	expand_strings: BOOLEAN

	known_objects: PC_TABLE [ PC_TYPED_IDENT [TI_], SI_]

invariant

	deep_definition: deep = ((flags & Order_flag) = Deep_flag)
	forward_definition: forward = ((flags & Order_flag) = Forward_flag)

note

	author: "Wolfgang Jansen"
	date: "$Date$"
	revision: "$Revision$"

end
