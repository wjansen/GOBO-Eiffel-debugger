note

	description:
		"[ 
		 Scanner the persistence closure of one object. 
		 Object attributes are scanned before the objects themselves or, 
		 in case of cyclic dependecy, get announced before the objects. 
		 ]"

class PC_FORWARD_DRIVER [TI_, SI_ -> attached ANY]
	-- TI_: type of idents generated by the `target' 
	-- SI_: type of idents generated by the `source' 

inherit

	PC_RANDOM_ACCESS_DRIVER [TI_, SI_]
		rename
			make as make_random_access
		redefine
			valid_flags,
			process_announcement
		end

create

	make

feature {NONE} -- Initialization
	
	make (t: like target; s: like source; oo: like known_objects)
		note
			action: ""
			t: "traversal target"
			s: "traversal source"
		require
			when_target_expands_strings: t.must_expand_strings implies s.can_expand_strings
			when_source_expands_strings: s.must_expand_strings implies t.can_expand_strings
		do
			make_random_access (t, s, Forward_flag, 0, oo)
		end
	
feature -- Access 

	valid_flags (f: INTEGER): BOOLEAN
		do
			Result := f & Forward_flag = Forward_flag
		end

feature {NONE}

	process_announcement (si: SI_)
		note
			action:
				"[
				 Announce object of and put it as key into `known_objects',
				 its value is obtained from `target'.
				 ]"
			si: "source ident"
		require else
			no_ti: known_objects.has (si)
						 and then known_objects [si].ident = target.void_ident
		local	
			tid: PC_TYPED_IDENT [TI_]		
			t: IS_TYPE
			count, cap: NATURAL
		do
			source.adjust_to (si)
			t := source.last_dynamic_type
			count := source.last_count
			tid.make (target.void_ident, t, count)
			known_objects [si] := tid
			if t.is_special and then attached {IS_SPECIAL_TYPE} t as s then
				cap := source.last_capacity
				forward_special (s, count, si)
			elseif t.is_agent and then attached {IS_AGENT_TYPE} t as a then
				forward_agent (a, si)
			elseif expand_strings or else not (t.is_string or else t.is_unicode) then
				forward_fields (t, si)
			end
			tid := known_objects [si]
			if tid.ident = target_void_ident then
				forward_data (t, count, cap, si)
			else
				process_data (si)
			end
		end

feature {NONE} -- Implementation 

	forward_data(t: IS_TYPE; count, cap: NATURAL; si: SI_)
		local
			tid: PC_TYPED_IDENT [TI_]
			ti: TI_
		do
			if t.is_special and then attached {IS_SPECIAL_TYPE} t as st then
				source.pre_special (st, count, si)
				target.pre_new_special (st, count, cap)
				ti := target.last_ident
				tid.make (ti, st, count)
				known_objects [si] := tid
				process_special (st, count, si, ti, True)
				source.post_special (st, si)
				target.post_special (st, ti)
			elseif t.is_agent and then attached {IS_AGENT_TYPE} t as at then
				source.pre_object (at, si)
				target.pre_new_object (at)
				ti := target.last_ident
				tid.make (ti, at, count)
				known_objects [si] := tid
				process_agent (at, si, ti, True)
				source.post_object (t, si)
				target.post_object (t, ti)				
			else
				source.pre_object (t, si)
				target.pre_new_object (t)
				ti := target.last_ident
				tid.make (ti, t, 0)
				known_objects [si] := tid
				process_normal_or_tuple (t, si, ti, True)
				source.post_object (t, si)
				target.post_object (t, ti)
			end
		end
	
	forward_fields (t: IS_TYPE; si: SI_)
		require
			si_not_null: attached si and then si /= source_void_ident
		local
			f: IS_FIELD
			ft: IS_TYPE
			k, n: INTEGER
		do
			n := t.field_count
			if n > 0 then
				source.pre_object (t, si)
				from
				until k = n loop
					f := t.field_at (k)
					ft := f.type
					if not ft.is_basic then
						source.set_field (f, si)
						forward_entity (ft)
					end
					k := k + 1
				end
				source.post_object (t, si)
			end
		end

	forward_agent (a: IS_AGENT_TYPE; si: SI_)
		require
			si_not_null: si /= source_void_ident
		local
			f: IS_FIELD
			ft: IS_TYPE
			k, n: INTEGER
		do
			n := a.closed_operand_count
			if n > 0 or else attached a.last_result then
				source.pre_object (a, si)
				if n > 0 then
					source.pre_agent (a, si)
					from
					until k = n loop
						f := a.field_at (k)
						ft := f.type
						if not ft.is_basic then
							source.set_field (f, si)
							forward_entity (ft)
						end
						k := k + 1
					end
					source.post_agent (a, si)
				end
				if attached a.last_result as r then
					f := r
					ft := f.type
					if not ft.is_basic then
						source.set_field (f, si)
						forward_entity (ft)
					end
				end
				source.post_object (a, si)
			end
		end

	forward_special (s: IS_SPECIAL_TYPE; n: NATURAL; si: SI_)
		note
			action: "Process `SPECIAL' of generic type `s'."
			n: "capacity"
			si: "source ident"
		require
			n_poitive: n > 0
			si_not_null: si /= source_void_ident
		local
			it: IS_TYPE
			k: NATURAL
		do
			it := s.item_type
			if not it.is_basic then
				source.pre_special (s, n, si)
				from
				until k = n loop
					source.set_index (s, k, si)
					forward_entity (it)
					k := k + 1
				end
				source.post_special (s, si)
			end
		end

	forward_entity (static: IS_TYPE)
		note
			action: "Announce entity."
		local
			tid: PC_TYPED_IDENT [TI_]
			ti: TI_
			t: IS_TYPE
			count: NATURAL
		do
			source.read_field_ident
			if attached source.last_ident as si then 
				if static.is_subobject then
					forward_fields (static, si)
				else
					if si /= source_void_ident then
						if not known_objects.has (si) then
							process_announcement (si)
						elseif known_objects [si].ident = target_void_ident then
							t := source.last_dynamic_type
							if t.is_special and then attached {IS_SPECIAL_TYPE} t as s then
								count := source.last_count
								target.put_new_special (s, count, source.last_capacity)
							else
								target.put_new_object (t)
							end
							ti := target.last_ident
							tid.make (ti, t, count)
							known_objects [si] := tid
						end
					end
				end
			end
		end

note

	author: "Wolfgang Jansen"
	date: "$Date$"
	revision: "$Revision$"

end
